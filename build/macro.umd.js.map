{"version":3,"file":"macro.umd.js","sources":["../node_modules/x-stringify/build/stringify.es.js","../src/getSourceFromNode.ts","../src/attr-actions.ts","../src/macro.ts","../src/logger.ts","../src/loadConfig.ts","../src/traverseJSXElement.ts","../src/nodeMatch.ts"],"sourcesContent":["function e(){return e=Object.assign?Object.assign.bind():function(e){for(var n=1;n<arguments.length;n++){var r=arguments[n];for(var t in r)Object.prototype.hasOwnProperty.call(r,t)&&(e[t]=r[t])}return e},e.apply(this,arguments)}function n(n,r){var t=Object.assign({indent:\"  \",maxDepth:4,showUndefined:!1,showNull:!0,leadingComma:!1},e({},r,{indent:void 0!==(null==r?void 0:r.indent)?\" \".repeat(r.indent):\"  \"})),i=new WeakSet,a=\"\",o=0;return function e(n,r){if(t.removeKeys&&t.removeKeys.includes(n))return!1;var f=\"\"===n?\"\":n+\": \",u=\"\"+t.indent.repeat(o),l=\"\"+u+f;if(void 0===r)return!!t.showUndefined&&(a+=l+\"undefined\",!0);if(null===r)return!!t.showNull&&(a+=l+\"null\",!0);if(r instanceof Date)return a+=l+'\"[Date: '+r.toISOString()+']\"',!0;if(\"symbol\"==typeof r)return a+=l+'\"[Symbol: '+r.toString()+']\"',!0;if(\"number\"==typeof r)return a+=\"\"+l+r,!0;if(\"string\"==typeof r)return a+=l+'\"'+r+'\"',!0;if(r instanceof RegExp)return a+=l+'\"[RegExp: '+r.toString()+']\"',!0;if(\"object\"==typeof r){if(i.has(r))return a+=l+'\"[circular ref]\"',!0;if(i.add(r),o++,Array.isArray(r)){a+=l+\"[\\n\";for(var s=0;s<r.length;s++)e(\"\",r[s])&&((t.leadingComma||s<r.length-1)&&(a+=\",\"),a+=\"\\n\");a+=u+\"]\"}else{if(t.maxDepth&&o>t.maxDepth)return a+=l+\"[max depth]\",o--,!0;a+=l+\"{\\n\";for(var d=Object.entries(r),p=0;p<d.length;p++){var g=d[p];e(g[0],g[1])&&((t.leadingComma||p<d.length-1)&&(a+=\",\"),a+=\"\\n\")}a+=u+\"}\"}return o--,!0}return a+=\"\"+l+r,!0}(\"\",n),a}export{n as stringify};\n//# sourceMappingURL=stringify.es.js.map\n","import type { NodePath, types as T } from \"@babel/core\";\n\nexport function getSourceFromNodePath(path: NodePath<T.Node>) {\n  const { default: generator } = require(\"@babel/generator\");\n  const code = generator(path.node).code;\n  return code;\n}\n\nexport function getSourceFromNode(node: T.Node) {\n  const { default: generator } = require(\"@babel/generator\");\n  const code = generator(node).code;\n  return code;\n}\n\nexport function generateNode(node: T.Node) {\n  const { default: generator } = require(\"@babel/generator\");\n  return generator(node);\n}\n","import type { NodePath, types as T } from \"@babel/core\";\nimport { Logger } from \"./logger\"\nimport { AttrMatch, FullLegalAttributeValues } from \"./attr-transform.config-types\"\nimport { getSourceFromNodePath } from \"./getSourceFromNode\"\n\nexport function replaceNameAndOrValue(foundProp: AttrMatch, t: typeof T, log: Logger) {\n  log.note(`Attr action: replaceName and/or replaceValue`, \"blackBright\");\n  let newName: string | undefined;\n  let id: T.JSXIdentifier | T.JSXNamespacedName | undefined;\n  // Optional new name\n  if (foundProp.attrConfig.replaceName) {\n    if (typeof foundProp.attrConfig.replaceName === \"string\") {\n      newName = foundProp.attrConfig.replaceName;\n    } else {\n      newName = foundProp.attrConfig.replaceName(foundProp);\n      log.msg(`[attrConfig.replaceName function]`, \"blackBright\");\n    }\n    log.note(`newName: ${newName}`, \"blackBright\");\n    if (newName) {\n      id = t.jsxIdentifier(newName);\n    }\n  } else {\n    id = foundProp.nodePath.node.name;\n  }\n  // Optional new value\n  let newValueNode: T.JSXAttribute[\"value\"] | undefined;\n  if (foundProp.attrConfig.replaceValue) {\n    let newValue: FullLegalAttributeValues | undefined;\n    if (typeof foundProp.attrConfig.replaceValue === \"string\") {\n      newValue = foundProp.attrConfig.replaceValue;\n    } else {\n      newValue = foundProp.attrConfig.replaceValue(foundProp);\n      log.msg(`[attrConfig.replaceValue funcrion]`, \"blackBright\");\n    }\n    if (typeof newValue === \"string\") {\n      log.msg(`[newValue: string]: ${newValue}`, \"blackBright\");\n      newValueNode = t.stringLiteral(newValue);\n    } else if (typeof newValue === \"number\") {\n      log.msg(`[newValue: number]: ${newValue}`, \"blackBright\");\n      newValueNode = t.jsxExpressionContainer(t.numericLiteral(newValue));\n    } else if (typeof newValue === \"boolean\") {\n      log.msg(`[newValue: bool]: ${newValue}`, \"blackBright\");\n      newValueNode = t.jsxExpressionContainer(t.booleanLiteral(newValue));\n    } else if (t.isNode(newValue)) {\n      log.msg(`[newValue: Node]: [Not printed]`, \"blackBright\");\n      newValueNode = newValue;\n    }\n  } else {\n    newValueNode = foundProp.nodePath.node.value;\n  }\n  // Replace attribute\n  if (id && newValueNode) {\n    const newAttr = t.jsxAttribute(id, newValueNode);\n    foundProp.nodePath.replaceWith(newAttr);\n  } else if (id) {\n    const newAttr = t.jsxAttribute(id, newValueNode);\n    foundProp.nodePath.replaceWith(newAttr);\n  } else if (newValueNode) {\n    foundProp.nodePath.replaceWith(newValueNode);\n  }\n  log.subheader(`Transformed Attribute`);\n  log.nodePath(foundProp.nodePath);\n}\n","import type { NodePath, types as T } from \"@babel/core\"\n\nimport { MacroError, createMacro } from \"babel-plugin-macros\"\nimport { x } from \"node-x-path\"\nimport { stringify } from \"x-stringify\"\n\nimport type { AttrTransformMacroParams } from \"./attr-transform.config-types\"\n\nimport { Logger } from \"./logger\"\nimport { getSourceFromNodePath } from \"./getSourceFromNode\"\nimport { loadConfig } from \"./loadConfig\"\nimport { traverseJSXElement } from \"./traverseJSXElement\"\n\nconst log = new Logger()\n\nlet sessionStartet = false\n\nfunction macro(params: AttrTransformMacroParams): void {\n  const t = params.babel.types\n  const program = params.state.file.path\n  const fileName = params.state.filename as string\n  log.enabled = true\n  log.header(`attr-transform.macro`)\n  log.note(`file: ${fileName}`)\n  const content = params.state.file.code\n  log.content = content\n\n  const attributesToRemove: NodePath<T.JSXAttribute>[] = []\n\n  const attrTransformConfig = loadConfig(params, log)\n\n  if (!attrTransformConfig.devMode) {\n    log.enabled = false\n  }\n\n  log.header(`Using Config`)\n  log.object(attrTransformConfig)\n  log.end()\n  log.header(`Start traverse ast`)\n\n  program.traverse({\n    JSXElement(path) {\n      traverseJSXElement(path, attrTransformConfig, params, attributesToRemove, t, log)\n    },\n  })\n\n  program.scope.crawl()\n  // remove all matched attributes\n  attributesToRemove.forEach((attrPath) => {\n    attrPath.remove()\n  })\n\n  // Print transformation\n\n  if (attrTransformConfig.devMode) {\n    const devMode = attrTransformConfig.devMode\n    const code = getSourceFromNodePath(program)\n    if (devMode.onlyTranformation) {\n      log.logLines = [] // clear log\n    }\n    if (devMode.onlyFiles) {\n      let onlyFiles = devMode.onlyFiles\n      const name = fileName.split(\"/\").pop()!\n      const nameNoExtension = name.replace(/\\.[^/.]+$/, \"\")\n      if (!Array.isArray(onlyFiles)) {\n        onlyFiles = [onlyFiles]\n      }\n      const fileNameMatch = onlyFiles.some((file) => {\n        if (typeof file === \"string\") {\n          return file === fileName || file === name || file === nameNoExtension\n        } else {\n          return file.test(fileName) || file.test(name) || file.test(nameNoExtension)\n        }\n      })\n      if (!fileNameMatch) {\n        return\n      }\n    }\n\n    log.msg(`\\n\\n`)\n    log.header(`Transformed Code`)\n    log.note(`jsx-transform.macro (DevMode Transformed)`)\n    log.note(`file: ${params.state.filename}`)\n\n    log.msg(code, \"white\")\n    log.msg(\"\\n\")\n    log.end()\n    log.msg(\"\\n\\n\")\n\n    let logMessage: string | undefined\n    if (devMode.colors === true) {\n      logMessage = log.getColorLog()\n    } else if (devMode.colors === false) {\n      logMessage = log.getLog()\n    }\n\n    if (devMode.logToConsole) {\n      if (logMessage === undefined) {\n        logMessage = log.getColorLog()\n      }\n      console.log(logMessage)\n    }\n    if (devMode.logWithThrow) {\n      if (logMessage === undefined) {\n        logMessage = log.getColorLog()\n      }\n      throw new MacroError(logMessage)\n    }\n    if (devMode.printToFile) {\n      if (logMessage === undefined) {\n        logMessage = log.getLog()\n      }\n      let deugFileName = \"attr-transform.macro.debug-log.txt\"\n      if (typeof devMode.printToFile === \"string\") {\n        deugFileName = devMode.printToFile\n      }\n      const path = require(\"path\")\n      const debugFilePath = path.join(process.cwd(), deugFileName)\n      if (!sessionStartet) {\n        sessionStartet = true\n        //fs.writeFileSync(debugFilePath, \"\") // clear file\n      }\n      const splitter = \"#####################__##__attr-tranform__##__#########################\"\n\n      const lastContent = x.loadSync(debugFilePath)\n      let fileLine = `########## ${fileName}`\n      const newContent = `\\n${fileLine}\\n${logMessage}`\n      if (lastContent.length > 0) {\n        const parts = lastContent.split(splitter)\n        // contains content\n        const findPart = parts.findIndex((part) => {\n          return part.includes(fileLine)\n        })\n        if (findPart >= 0) {\n          // already contains file line\n          parts.splice(findPart, 1, newContent)\n        } else {\n          parts.push(newContent)\n        }\n        const newFileContent = parts.join(splitter)\n        x.saveSync(debugFilePath, newFileContent)\n      } else {\n        const newFileContent = `${splitter}\\n${newContent}`\n        x.saveSync(debugFilePath, newFileContent)\n      }\n    }\n  }\n\n  log.msg(`\\n`)\n  log.header(\"attr-attribute.macro : DONE\", \"blackBright\")\n  log.msg(`\\n\\n`)\n}\n\nexport default createMacro(macro, { configName: \"attr-transform\" })\n","import clc from \"cli-color\"\nimport { stringify } from \"x-stringify\"\nimport { getSourceFromNode, getSourceFromNodePath } from \"./getSourceFromNode\"\n\nexport type Colors =\n  | \"black\"\n  | \"red\"\n  | \"green\"\n  | \"yellow\"\n  | \"blue\"\n  | \"magenta\"\n  | \"cyan\"\n  | \"white\"\n  | \"bgBlack\"\n  | \"bgRed\"\n  | \"bgGreen\"\n  | \"bgYellow\"\n  | \"bgBlue\"\n  | \"bgMagenta\"\n  | \"bgCyan\"\n  | \"bgWhite\"\n  | \"blackBright\"\n  | \"redBright\"\n  | \"greenBright\"\n  | \"yellowBright\"\n  | \"blueBright\"\n  | \"magentaBright\"\n  | \"cyanBright\"\n  | \"whiteBright\"\n  | \"bgBlackBright\"\n  | \"bgRedBright\"\n  | \"bgGreenBright\"\n  | \"bgYellowBright\"\n  | \"bgBlueBright\"\n  | \"bgMagentaBright\"\n  | \"bgCyanBright\"\n  | \"bgWhiteBright\"\n\nexport class Logger {\n  logLines: { msg: string; color: Colors }[] = []\n  content: string = \"\"\n  indent = 2\n  maxDepth = 4\n  showUndefined = false\n  showNull = true\n  lineWith = 80\n\n  enabled = false\n\n  stringify(obj: object, maxDepth: number = this.maxDepth) {\n    return stringify(obj, {\n      indent: this.indent,\n      maxDepth,\n      showUndefined: this.showUndefined,\n      showNull: this.showNull,\n    })\n  }\n\n  object(obj: any, color: Colors = \"white\", maxDepth?: number) {\n    if (this.enabled) {\n      let json = this.stringify(obj, maxDepth)\n      this.msg(json, color)\n    }\n  }\n\n  nodePath(nodePath: any, color: Colors = \"white\") {\n    if (this.enabled) {\n      const code = getSourceFromNodePath(nodePath)\n      this.msg(code, color)\n    }\n  }\n  node(node: any, color: Colors = \"white\") {\n    if (this.enabled) {\n      const code = getSourceFromNode(node)\n      this.msg(code, color)\n    }\n  }\n\n  msg(message: string, color: Colors = \"white\") {\n    if (this.enabled) {\n      this.logLines.push({ msg: message, color })\n    }\n  }\n  contentLine(line: number, color: Colors = \"white\") {\n    if (this.enabled) {\n      let message = `${line}: ` + this.content.split(\"\\n\")[line - 1]\n      this.logLines.push({ msg: message, color })\n    }\n  }\n  note(message: string, color: Colors = \"blackBright\") {\n    if (this.enabled) {\n      this.line(message, \"## -- \", false, color)\n    }\n  }\n  header(message: string, color: Colors = \"cyan\") {\n    if (this.enabled) {\n      this.line(message, \"## \", true, color)\n    }\n  }\n  subheader(message: string, color: Colors = \"cyan\") {\n    if (this.enabled) {\n      this.line(message, \">> \", false, color)\n    }\n  }\n  end(color: Colors = \"blackBright\") {\n    if (this.enabled) {\n      this.line(\"\", \"---- - - - - -\", true, color)\n    }\n  }\n  line(message: string, prefix = \"\", header: boolean, color: Colors = \"white\") {\n    if (this.enabled) {\n      let msg = `${prefix}${message} `\n      let len = msg.length\n      if (len < this.lineWith) {\n        let space = this.lineWith - len\n        let char = header ? \"-\" : \" \"\n        msg += char.repeat(space)\n      }\n      this.logLines.push({ msg, color })\n    }\n  }\n\n  getColorLog() {\n    return this.logLines.map((x) => clc[x.color](x.msg)).join(\"\\n\")\n  }\n  getLog() {\n    return this.logLines.map((x) => x.msg).join(\"\\n\")\n  }\n}\n","import { MacroError } from \"babel-plugin-macros\"\nimport { join } from \"path\"\n\nimport type { AttrTransformConfig, AttrTransformMacroParams } from \"./attr-transform.config-types\"\n\nimport { Logger } from \"./logger\"\n\nexport function loadConfig(params: AttrTransformMacroParams, log: Logger): AttrTransformConfig {\n  let config: AttrTransformConfig = {}\n  const { config: babelMacroConfig } = params\n  log.header(`Config`)\n  log.note(`(from babel-macro-pluing under 'attr-transform' section)`)\n  log.object(babelMacroConfig)\n  log.end()\n\n  // Get the config in babel-macro config: https://github.com/kentcdodds/babel-plugin-macros/blob/main/other/docs/author.md\n  // Or from file\n\n  let configFile: string | undefined = undefined\n  if (babelMacroConfig?.config === undefined) {\n    configFile = \"attr-transform.config.cjs\"\n  } else if (typeof babelMacroConfig?.config === \"string\") {\n    configFile = babelMacroConfig.config\n  } else {\n    config = babelMacroConfig\n  }\n\n  if (configFile) {\n    const baseDirectory = process.cwd()\n    //throw new MacroError(\"baseDirectory: \" + baseDirectory)\n    //log(\"baseDirectory: \" + baseDirectory, \"configFile: \" + configFile)\n    const configFilePath = join(baseDirectory, configFile)\n    log.note(`Loading config from file: `, \"cyan\")\n    log.note(`path: ${configFilePath}`, \"blackBright\")\n    const configFromFile = require(configFilePath) as AttrTransformConfig\n    config = configFromFile\n  } else if (babelMacroConfig?.elms) {\n    config = babelMacroConfig\n  } else {\n    throw new MacroError(\n      `\n        You must provide a config file (or a 'attr-transform.elms' object in the babel-plugin-macro config - https://github.com/kentcdodds/babel-plugin-macros/blob/main/other/docs/author.md):\n        [attr-transform.config.js]\n        /** @type {import('../src/twin-atttributes.types.ts').TwinAttributeConfig} */\n        module.exports = {\n          elms: [\n            {\n              attrs: {\n                padding: {\n                  matchName: /p([0-9])/,\n                  replaceValue: ({match}) => \\`p-\\${match[1]}\\`,\n                },\n                color: {\n                  matchName: /([red|blue|green])/,\n                  replaceValue: ({match}) => \\`text-\\${match[1]}-600\\`,\n                },\n                line: {\n                  matchName: /line-([0-9])/,\n                  replaceValue: \"flex items-center justify-start\",\n                } \n              },\n            },\n          ],\n        }\n        `\n    )\n  }\n\n  if (config.devMode && config.devMode.maxDepth) {\n    log.maxDepth = config.devMode.maxDepth\n  }\n  return config\n}\n","import type { NodePath, types as T } from \"@babel/core\";\n\nimport { MacroError, createMacro } from \"babel-plugin-macros\";\nimport { join } from \"path\";\nimport cli from \"cli-color\";\n\nimport type {\n  AttrMatch,\n  AttrTransformConfig,\n  AttrTransformMacroParams,\n  FullLegalAttributeValues,\n  PostActionMatch,\n  PostMatchAction,\n} from \"./attr-transform.config-types\"\nimport { FindMatchingAttributesConfig, MatchElm, getJsxAttributes } from \"./nodeMatch\"\nimport { replaceNameAndOrValue } from \"./attr-actions\"\n\nimport { Logger } from \"./logger\"\n\nexport function traverseJSXElement(\n  path: NodePath<T.JSXElement>,\n  attrTransformConfig: AttrTransformConfig,\n  params: AttrTransformMacroParams,\n  attributesToRemove: NodePath<T.JSXAttribute>[],\n  t: typeof T,\n  log: Logger\n) {\n  if (!attrTransformConfig.elms) return;\n\n  const jsxAttributePaths = getJsxAttributes(path);\n\n  // Test matching tag (elm)\n  const { elm, tagName, tagMatch, matchingElmConfig } = MatchElm(path, attrTransformConfig.elms);\n  const line = elm.node.loc?.start.line ?? 0;\n  const end = elm.node.loc?.start.line ?? 0;\n  const startColumn = elm.node.loc?.start.column;\n  const endColumn = elm.node.loc?.start.column;\n  const lines = end - line + 1;\n  log.header(`traverse - JSXElement: ${tagName} - Line: ${line}:${startColumn} to ${end}:${endColumn}`, \"bgBlue\");\n  if (lines < 4) {\n    for (let i = 0; i < lines; i++) {\n      log.contentLine(line + i);\n    }\n  } else {\n    log.contentLine(line + 1);\n    log.contentLine(line + 2);\n    log.msg(`...`);\n    log.contentLine(end - 1);\n    log.contentLine(end);\n  }\n\n  if (!matchingElmConfig) {\n    log.note(`No Elm Confiog not macthed!`, \"redBright\");\n    log.end();\n    return false;\n  }\n\n  // Match attributes\n  const foundAttributes = jsxAttributePaths\n    .map((attrPath) => FindMatchingAttributesConfig(params, matchingElmConfig, elm, tagMatch, attrPath))\n    // remove undefined\n    .filter((x) => !!x) as AttrMatch[];\n  // list elm actions\n  const postMatchActions: PostMatchAction[] = matchingElmConfig.actions ?? [];\n\n  if (foundAttributes.length === 0 && postMatchActions.length === 0) {\n    log.note(`No attribute matched and no actions defined\\n`, \"redBright\");\n    log.end();\n\n    return;\n  }\n  log.note(\n    `Found ${foundAttributes.length} attributes: ${foundAttributes.map((x) => x.nodePath.node.name.name).join(\", \")}`\n  );\n\n  const collectedAttributes: AttrMatch[] = [];\n  const steps: { [key: string]: (foundProp: AttrMatch) => void } = {\n    collect: (foundProp) => {\n      if (foundProp.collected) {\n        collectedAttributes.push(foundProp);\n      }\n    },\n    setMeta: (foundProp) => {\n      foundProp.allMatchingAttributes = foundAttributes;\n      foundProp.collectedAttributes = collectedAttributes;\n    },\n    setValues: (foundProp) => {\n      if (foundProp?.valueFunction) {\n        foundProp.value = foundProp.valueFunction(foundProp);\n      }\n    },\n    callValidators: (foundProp) => {\n      if (foundProp?.validateFunction) {\n        const errorMessage = foundProp.validateFunction(foundProp);\n        if (errorMessage) {\n          let errorText =\n            cli.redBright(\"âŒ\") +\n            cli.redBright(\" Validation error\") +\n            cli.blackBright(\" (jsx-transform.macro)\") +\n            cli.blackBright(\"\\n\\n in \") +\n            cli.cyan(params.state.filename) +\n            cli.blackBright(\"\\n at \") +\n            cli.cyan(\"line \" + path.node.loc?.start.line) +\n            cli.blackBright(\":\\n\\n  \") +\n            cli.red(\"  \" + errorMessage);\n\n          throw new MacroError(`\\n\\n${errorText}\\n\\n`);\n        }\n      }\n    },\n  };\n\n  // Run steps\n  Object.values(steps).forEach((step) => {\n    foundAttributes.forEach(step);\n  });\n\n  log.note(`Run attribute actions (count: ${foundAttributes.length})`, \"blackBright\");\n  // Attributes Actions\n  for (const foundProp of foundAttributes) {\n    log.subheader(`Attr: ${foundProp.nodePath.node.name.name} - Source:`, \"cyan\");\n    log.nodePath(foundProp.nodePath);\n    log.subheader(`Value from attr config: ${foundProp.value}`, \"blackBright\");\n    if (foundProp.attrConfig.replaceName || foundProp.attrConfig.replaceValue) {\n      replaceNameAndOrValue(foundProp, t, log);\n    }\n    log.note(`End attribute parsing`);\n  }\n\n  log.subheader(`Run elm actions conditions`, \"blackBright\");\n\n  const matchedActions = postMatchActions\n    .map((action) => {\n      const matchAction: PostActionMatch = {\n        name: action.name ?? \"\",\n        value: \"\",\n        postMatchAction: action,\n        allMatchingAttributes: foundAttributes,\n        collectedAttributes: collectedAttributes,\n        elmNodePath: elm,\n        tagMatch: tagMatch,\n        macroParams: params,\n      };\n      // conditions\n      if (action.condition) {\n        const match = action.condition(matchAction);\n        if (!match) return;\n\n        if (action.value && typeof action.value === \"function\") {\n          matchAction.value = action.value(matchAction);\n        } else if (action.value) {\n          matchAction.value = action.value;\n        }\n\n        return matchAction;\n      }\n      return matchAction;\n    })\n    .filter((x) => !!x) as PostActionMatch[];\n\n  log.note(`Found ${postMatchActions.length} Elm actions: ${postMatchActions.map((x) => x.name)}`);\n\n  log.note(`Macthed Elm action  - (condition met) (count: ${matchedActions.length})`, \"blackBright\");\n\n  // Post match actions\n  for (const action of matchedActions) {\n    log.subheader(`Action: ${action.name ?? \" (no name)\"}`, \"cyan\");\n\n    let value = action.value;\n\n    if (action.postMatchAction.createAttribute) {\n      log.note(`Elm action: createAttribute`, \"blackBright\");\n\n      const attr = action.postMatchAction.createAttribute;\n      if (typeof attr === \"string\") {\n        const newAttrName = attr;\n        const existingAttribute = jsxAttributePaths.find((attr) => attr.node.name.name === newAttrName);\n        // New value:\n        let newAttr: T.JSXAttribute | undefined;\n        const id = t.jsxIdentifier(newAttrName);\n        if (!value) {\n          newAttr = t.jsxAttribute(id);\n        } else if (typeof value === \"string\") {\n          newAttr = t.jsxAttribute(id, t.stringLiteral(value));\n        } else if (typeof value === \"number\") {\n          newAttr = t.jsxAttribute(id, t.jsxExpressionContainer(t.numericLiteral(value)));\n        } else if (typeof value === \"boolean\") {\n          newAttr = t.jsxAttribute(id, t.jsxExpressionContainer(t.booleanLiteral(value)));\n        } else if (t.isNode(value)) {\n          newAttr = t.jsxAttribute(id, value);\n        }\n        if (newAttr) {\n          if (!existingAttribute) {\n            // Add new attribute\n            elm.node.attributes.push(newAttr);\n            log.note(`attribute added`);\n            log.object(newAttr);\n          } else if (action.value) {\n            existingAttribute.replaceWith(newAttr);\n            log.note(`existing attribute replaced`);\n            log.nodePath(existingAttribute);\n          }\n        }\n      }\n    }\n  }\n\n  // remove props\n  for (const foundProp of foundAttributes) {\n    if (attributesToRemove.includes(foundProp.nodePath)) continue;\n    if (foundProp.attrConfig.remove) {\n      attributesToRemove.push(foundProp.nodePath);\n    }\n  }\n}\n","import type { NodePath, types as T } from \"@babel/core\";\n\nimport type {\n  AttrMatch,\n  AttrTransformMacroParams,\n  AttrValueFunc,\n  ElmConfig,\n  MatchValueFunc,\n  ValidateValueFunc,\n} from \"./attr-transform.config-types\"\n\nexport function getJsxAttributes(nodePath: NodePath<T.JSXElement>) {\n  let attributes = nodePath.get(\"openingElement.attributes\") as NodePath<T.JSXAttribute>[];\n  if (!Array.isArray(attributes)) {\n    attributes = [attributes];\n  }\n  return attributes.filter((x) => x?.isJSXAttribute());\n}\n\nexport function MatchElm(path: NodePath<T.JSXElement>, elms: ElmConfig[]) {\n  const elm = path.get(\"openingElement\");\n  const tagName = (elm.node.name as T.JSXIdentifier).name?.toString() ?? \"\";\n  if (!tagName) return { elm, tagName, tagMatch: null, matchingElmConfig: undefined };\n  let tagMatch: RegExpMatchArray | null = null;\n  const matchingElmConfig = elms.find((elmConfig) => {\n    if (elmConfig.match === undefined) return true;\n    if (typeof elmConfig.match === \"string\") {\n      tagMatch = tagName === elmConfig.match ? [tagName] : null;\n    }\n    if (elmConfig.match instanceof RegExp) {\n      tagMatch = tagName.match(elmConfig.match);\n    }\n    if (!tagMatch) return false;\n    if (elmConfig.dontMatch) {\n      const dontMatch = tagName.match(elmConfig.dontMatch);\n      if (dontMatch) return false;\n    }\n    return true;\n  });\n  return { elm, tagName, tagMatch, matchingElmConfig };\n}\n\nexport function FindMatchingAttributesConfig(\n  macroParams: AttrTransformMacroParams,\n  elmConfig: ElmConfig,\n  elmNodePath: NodePath<T.JSXOpeningElement>,\n  tagRegExpMatch: RegExpMatchArray | null,\n  attrNodePath: NodePath<T.JSXAttribute>\n): AttrMatch | undefined {\n  if (!attrNodePath.node || !elmNodePath.node) return;\n  if (attrNodePath.removed) return;\n  const attrName = attrNodePath.node.name.name.toString();\n  const attrsConfig = Object.entries(elmConfig.attrs);\n  // iterate attrConfig (elm attributes)\n  for (const [name, attrConfig] of attrsConfig) {\n    let attrMatch: RegExpMatchArray | null = null;\n    let value = \"\";\n    let valueFunction: AttrValueFunc | undefined;\n    let validateFunction: ValidateValueFunc | undefined;\n    let matchFunction: MatchValueFunc | undefined;\n    let dontMatchFunction: MatchValueFunc | undefined;\n\n    // match\n    if (attrConfig.matchName) {\n      if (typeof attrConfig.matchName === \"string\") {\n        attrMatch = attrName === attrConfig.matchName ? [attrName] : null;\n        if (!attrMatch) continue; // no match\n      }\n      if (attrConfig.matchName instanceof RegExp) {\n        attrMatch = attrName.match(attrConfig.matchName);\n        if (!attrMatch) continue; // no match\n      }\n      if (typeof attrConfig.matchName === \"function\") {\n        matchFunction = attrConfig.matchName; // finish after collect all attributes\n      }\n    }\n    // dontMatch\n    if (attrConfig.dontMatchName) {\n      if (typeof attrConfig.dontMatchName === \"string\") {\n        const dontMatch = attrName === attrConfig.dontMatchName;\n        if (dontMatch) continue; // no match\n      }\n      if (attrConfig.dontMatchName instanceof RegExp) {\n        const dontMatch = attrName.match(attrConfig.dontMatchName);\n        if (dontMatch) continue; // no match\n      }\n      if (typeof attrConfig.dontMatchName === \"function\") {\n        dontMatchFunction = attrConfig.dontMatchName; // finish after collect all attributes\n      }\n    }\n    // validate\n    if (typeof attrConfig.validate === \"function\") {\n      validateFunction = attrConfig.validate; // finish after collect all attributes\n    }\n    // value\n    if (typeof attrConfig.value === \"string\") {\n      value = attrConfig.value;\n    } else if (typeof attrConfig.value === \"function\") {\n      valueFunction = attrConfig.value; // finish after collect all attributes\n    } else if (typeof attrConfig.replaceValue === \"function\") {\n      valueFunction = attrConfig.replaceValue; // finish after collect all attributes\n    } else {\n      // is string literal\n      if (attrNodePath.node.value?.type === \"StringLiteral\") {\n        value = attrNodePath.node.value?.value?.toString() ?? \"\";\n      }\n    }\n\n    let collected = attrConfig.collect ?? false;\n\n    const fount: AttrMatch = {\n      name,\n      value, // set from attrConfig function call later\n      matchFunction,\n      dontMatchFunction,\n      validateFunction,\n      valueFunction,\n      attrConfig,\n      match: attrMatch,\n      collected,\n      tagMatch: tagRegExpMatch,\n      allMatchingAttributes: [], // finish after collect all attributes: get after grouping\n      collectedAttributes: [], // finish after collect all attributes: get after grouping\n      nodePath: attrNodePath,\n      elmNodePath: elmNodePath,\n      macroParams,\n    };\n    return fount;\n  }\n}\n"],"names":["e","Object","assign","bind","n","arguments","length","r","t","prototype","hasOwnProperty","call","apply","this","getSourceFromNodePath","path","generator","require","node","code","replaceNameAndOrValue","foundProp","log","newName","id","newValueNode","newValue","note","attrConfig","replaceName","msg","jsxIdentifier","nodePath","name","replaceValue","stringLiteral","jsxExpressionContainer","numericLiteral","booleanLiteral","isNode","value","newAttr","jsxAttribute","replaceWith","subheader","Logger","logLines","content","indent","maxDepth","showUndefined","showNull","lineWith","enabled","_proto","stringify","obj","leadingComma","repeat","i","WeakSet","a","o","removeKeys","includes","f","u","l","Date","toISOString","toString","RegExp","has","add","Array","isArray","s","d","entries","p","g","object","color","json","message","push","contentLine","line","split","header","end","prefix","len","getColorLog","map","x","clc","join","getLog","createMacro","params","babel","types","program","state","file","fileName","filename","attributesToRemove","attrTransformConfig","config","babelMacroConfig","configFile","undefined","baseDirectory","process","cwd","configFilePath","elms","MacroError","devMode","loadConfig","traverse","JSXElement","_elm$node$loc$start$l","_elm$node$loc","_elm$node$loc$start$l2","_elm$node$loc2","_elm$node$loc3","_elm$node$loc4","_matchingElmConfig$ac","attributes","jsxAttributePaths","get","filter","isJSXAttribute","_MatchElm","_elm$node$name$name$t","_elm$node$name$name","elm","tagName","tagMatch","matchingElmConfig","find","elmConfig","match","dontMatch","MatchElm","loc","start","startColumn","column","endColumn","lines","foundAttributes","attrPath","macroParams","elmNodePath","tagRegExpMatch","attrNodePath","removed","attrName","_i","_attrsConfig","attrs","_attrConfig$collect","_attrsConfig$_i","attrMatch","valueFunction","validateFunction","matchFunction","dontMatchFunction","matchName","dontMatchName","validate","_attrNodePath$node$va","_attrNodePath$node$va2","_attrNodePath$node$va3","_attrNodePath$node$va4","type","collected","collect","allMatchingAttributes","collectedAttributes","FindMatchingAttributesConfig","postMatchActions","actions","steps","setMeta","setValues","callValidators","errorMessage","_path$node$loc","errorText","cli","redBright","blackBright","cyan","red","values","forEach","step","_iterator","_step","_createForOfIteratorHelperLoose","done","matchedActions","action","_action$name","matchAction","postMatchAction","condition","_step2","_loop","_action$name2","createAttribute","attr","newAttrName","existingAttribute","_iterator2","_iterator3","_step3","remove","traverseJSXElement","scope","crawl","logMessage","onlyTranformation","onlyFiles","pop","nameNoExtension","replace","some","test","colors","logToConsole","console","logWithThrow","printToFile","deugFileName","debugFilePath","splitter","lastContent","loadSync","fileLine","newContent","parts","findPart","findIndex","part","splice","newFileContent","saveSync","configName"],"mappings":"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"}