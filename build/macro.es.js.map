{"version":3,"file":"macro.es.js","sources":["../node_modules/x-stringify/build/stringify.es.js","../src/getSourceFromNode.ts","../src/logger.ts","../src/attr-actions.ts","../src/macro.ts","../src/loadConfig.ts","../src/traverseJSXElement.ts","../src/nodeMatch.ts"],"sourcesContent":["function e(){return e=Object.assign?Object.assign.bind():function(e){for(var n=1;n<arguments.length;n++){var r=arguments[n];for(var t in r)Object.prototype.hasOwnProperty.call(r,t)&&(e[t]=r[t])}return e},e.apply(this,arguments)}function n(n,r){var t=Object.assign({indent:\"  \",maxDepth:4,showUndefined:!1,showNull:!0,leadingComma:!1},e({},r,{indent:void 0!==(null==r?void 0:r.indent)?\" \".repeat(r.indent):\"  \"})),i=new WeakSet,a=\"\",o=0;return function e(n,r){if(t.removeKeys&&t.removeKeys.includes(n))return!1;var f=\"\"===n?\"\":n+\": \",u=\"\"+t.indent.repeat(o),l=\"\"+u+f;if(void 0===r)return!!t.showUndefined&&(a+=l+\"undefined\",!0);if(null===r)return!!t.showNull&&(a+=l+\"null\",!0);if(r instanceof Date)return a+=l+'\"[Date: '+r.toISOString()+']\"',!0;if(\"symbol\"==typeof r)return a+=l+'\"[Symbol: '+r.toString()+']\"',!0;if(\"number\"==typeof r)return a+=\"\"+l+r,!0;if(\"string\"==typeof r)return a+=l+'\"'+r+'\"',!0;if(r instanceof RegExp)return a+=l+'\"[RegExp: '+r.toString()+']\"',!0;if(\"object\"==typeof r){if(i.has(r))return a+=l+'\"[circular ref]\"',!0;if(i.add(r),o++,Array.isArray(r)){a+=l+\"[\\n\";for(var s=0;s<r.length;s++)e(\"\",r[s])&&((t.leadingComma||s<r.length-1)&&(a+=\",\"),a+=\"\\n\");a+=u+\"]\"}else{if(t.maxDepth&&o>t.maxDepth)return a+=l+\"[max depth]\",o--,!0;a+=l+\"{\\n\";for(var d=Object.entries(r),p=0;p<d.length;p++){var g=d[p];e(g[0],g[1])&&((t.leadingComma||p<d.length-1)&&(a+=\",\"),a+=\"\\n\")}a+=u+\"}\"}return o--,!0}return a+=\"\"+l+r,!0}(\"\",n),a}export{n as stringify};\n//# sourceMappingURL=stringify.es.js.map\n","import type { NodePath, types as T } from \"@babel/core\";\n\nexport function getSourceFromNodePath(path: NodePath<T.Node>) {\n  const { default: generator } = require(\"@babel/generator\");\n  const code = generator(path.node).code;\n  return code;\n}\n\nexport function getSourceFromNode(node: T.Node) {\n  const { default: generator } = require(\"@babel/generator\");\n  const code = generator(node).code;\n  return code;\n}\n\nexport function generateNode(node: T.Node) {\n  const { default: generator } = require(\"@babel/generator\");\n  return generator(node);\n}\n","import clc from \"cli-color\"\nimport { stringify } from \"x-stringify\"\nimport { getSourceFromNode, getSourceFromNodePath } from \"./getSourceFromNode\"\n\nexport type Colors =\n  | \"black\"\n  | \"red\"\n  | \"green\"\n  | \"yellow\"\n  | \"blue\"\n  | \"magenta\"\n  | \"cyan\"\n  | \"white\"\n  | \"bgBlack\"\n  | \"bgRed\"\n  | \"bgGreen\"\n  | \"bgYellow\"\n  | \"bgBlue\"\n  | \"bgMagenta\"\n  | \"bgCyan\"\n  | \"bgWhite\"\n  | \"blackBright\"\n  | \"redBright\"\n  | \"greenBright\"\n  | \"yellowBright\"\n  | \"blueBright\"\n  | \"magentaBright\"\n  | \"cyanBright\"\n  | \"whiteBright\"\n  | \"bgBlackBright\"\n  | \"bgRedBright\"\n  | \"bgGreenBright\"\n  | \"bgYellowBright\"\n  | \"bgBlueBright\"\n  | \"bgMagentaBright\"\n  | \"bgCyanBright\"\n  | \"bgWhiteBright\"\n\nexport class Logger {\n  logLines: { msg: string; color: Colors }[] = []\n  content: string = \"\"\n  indent = 2\n  maxDepth = 4\n  showUndefined = false\n  showNull = true\n  lineWith = 80\n\n  enabled = false\n\n  stringify(obj: object, maxDepth: number = this.maxDepth) {\n    return stringify(obj, {\n      indent: this.indent,\n      maxDepth,\n      showUndefined: this.showUndefined,\n      showNull: this.showNull,\n    })\n  }\n\n  object(obj: any, color: Colors = \"white\", maxDepth?: number) {\n    if (this.enabled) {\n      let json = this.stringify(obj, maxDepth)\n      this.msg(json, color)\n    }\n  }\n\n  nodePath(nodePath: any, color: Colors = \"white\") {\n    if (this.enabled) {\n      const code = getSourceFromNodePath(nodePath)\n      this.msg(code, color)\n    }\n  }\n  node(node: any, color: Colors = \"white\") {\n    if (this.enabled) {\n      const code = getSourceFromNode(node)\n      this.msg(code, color)\n    }\n  }\n\n  msg(message: string, color: Colors = \"white\") {\n    if (this.enabled) {\n      this.logLines.push({ msg: message, color })\n    }\n  }\n  contentLine(line: number, color: Colors = \"white\") {\n    if (this.enabled) {\n      let message = `${line}: ` + this.content.split(\"\\n\")[line - 1]\n      this.logLines.push({ msg: message, color })\n    }\n  }\n  note(message: string, color: Colors = \"blackBright\") {\n    if (this.enabled) {\n      this.line(message, \"## -- \", false, color)\n    }\n  }\n  header(message: string, color: Colors = \"cyan\") {\n    if (this.enabled) {\n      this.line(message, \"## \", true, color)\n    }\n  }\n  subheader(message: string, color: Colors = \"cyan\") {\n    if (this.enabled) {\n      this.line(message, \">> \", false, color)\n    }\n  }\n  end(color: Colors = \"blackBright\") {\n    if (this.enabled) {\n      this.line(\"\", \"---- - - - - -\", true, color)\n    }\n  }\n  line(message: string, prefix = \"\", header: boolean, color: Colors = \"white\") {\n    if (this.enabled) {\n      let msg = `${prefix}${message} `\n      let len = msg.length\n      if (len < this.lineWith) {\n        let space = this.lineWith - len\n        let char = header ? \"-\" : \" \"\n        msg += char.repeat(space)\n      }\n      this.logLines.push({ msg, color })\n    }\n  }\n\n  getColorLog() {\n    return this.logLines.map((x) => clc[x.color](x.msg)).join(\"\\n\")\n  }\n  getLog() {\n    return this.logLines.map((x) => x.msg).join(\"\\n\")\n  }\n}\n","import type { NodePath, types as T } from \"@babel/core\";\nimport { Logger } from \"./logger\"\nimport { AttrMatch, FullLegalAttributeValues } from \"./attr-transform.config-types\"\nimport { getSourceFromNodePath } from \"./getSourceFromNode\"\n\nexport function replaceNameAndOrValue(foundProp: AttrMatch, t: typeof T, log: Logger) {\n  log.note(`Attr action: replaceName and/or replaceValue`, \"blackBright\");\n  let newName: string | undefined;\n  let id: T.JSXIdentifier | T.JSXNamespacedName | undefined;\n  // Optional new name\n  if (foundProp.attrConfig.replaceName) {\n    if (typeof foundProp.attrConfig.replaceName === \"string\") {\n      newName = foundProp.attrConfig.replaceName;\n    } else {\n      newName = foundProp.attrConfig.replaceName(foundProp);\n      log.msg(`[attrConfig.replaceName function]`, \"blackBright\");\n    }\n    log.note(`newName: ${newName}`, \"blackBright\");\n    if (newName) {\n      id = t.jsxIdentifier(newName);\n    }\n  } else {\n    id = foundProp.nodePath.node.name;\n  }\n  // Optional new value\n  let newValueNode: T.JSXAttribute[\"value\"] | undefined;\n  if (foundProp.attrConfig.replaceValue) {\n    let newValue: FullLegalAttributeValues | undefined;\n    if (typeof foundProp.attrConfig.replaceValue === \"string\") {\n      newValue = foundProp.attrConfig.replaceValue;\n    } else {\n      newValue = foundProp.attrConfig.replaceValue(foundProp);\n      log.msg(`[attrConfig.replaceValue funcrion]`, \"blackBright\");\n    }\n    if (typeof newValue === \"string\") {\n      log.msg(`[newValue: string]: ${newValue}`, \"blackBright\");\n      newValueNode = t.stringLiteral(newValue);\n    } else if (typeof newValue === \"number\") {\n      log.msg(`[newValue: number]: ${newValue}`, \"blackBright\");\n      newValueNode = t.jsxExpressionContainer(t.numericLiteral(newValue));\n    } else if (typeof newValue === \"boolean\") {\n      log.msg(`[newValue: bool]: ${newValue}`, \"blackBright\");\n      newValueNode = t.jsxExpressionContainer(t.booleanLiteral(newValue));\n    } else if (t.isNode(newValue)) {\n      log.msg(`[newValue: Node]: [Not printed]`, \"blackBright\");\n      newValueNode = newValue;\n    }\n  } else {\n    newValueNode = foundProp.nodePath.node.value;\n  }\n  // Replace attribute\n  if (id && newValueNode) {\n    const newAttr = t.jsxAttribute(id, newValueNode);\n    foundProp.nodePath.replaceWith(newAttr);\n  } else if (id) {\n    const newAttr = t.jsxAttribute(id, newValueNode);\n    foundProp.nodePath.replaceWith(newAttr);\n  } else if (newValueNode) {\n    foundProp.nodePath.replaceWith(newValueNode);\n  }\n  log.subheader(`Transformed Attribute`);\n  log.nodePath(foundProp.nodePath);\n}\n","import type { NodePath, types as T } from \"@babel/core\"\n\nimport { MacroError, createMacro } from \"babel-plugin-macros\"\nimport { x } from \"node-x-path\"\nimport { stringify } from \"x-stringify\"\n\nimport type { AttrTransformMacroParams } from \"./attr-transform.config-types\"\n\nimport { Logger } from \"./logger\"\nimport { getSourceFromNodePath } from \"./getSourceFromNode\"\nimport { loadConfig } from \"./loadConfig\"\nimport { traverseJSXElement } from \"./traverseJSXElement\"\n\nconst log = new Logger()\n\nlet sessionStartet = false\n\nfunction macro(params: AttrTransformMacroParams): void {\n  const t = params.babel.types\n  const program = params.state.file.path\n  const fileName = params.state.filename as string\n  log.enabled = true\n  log.header(`attr-transform.macro`)\n  log.note(`file: ${fileName}`)\n  const content = params.state.file.code\n  log.content = content\n\n  const attributesToRemove: NodePath<T.JSXAttribute>[] = []\n\n  const attrTransformConfig = loadConfig(params, log)\n\n  if (!attrTransformConfig.devMode) {\n    log.enabled = false\n  }\n\n  log.header(`Using Config`)\n  log.object(attrTransformConfig)\n  log.end()\n  log.header(`Start traverse ast`)\n\n  program.traverse({\n    JSXElement(path) {\n      traverseJSXElement(path, attrTransformConfig, params, attributesToRemove, t, log)\n    },\n  })\n\n  program.scope.crawl()\n  // remove all matched attributes\n  attributesToRemove.forEach((attrPath) => {\n    attrPath.remove()\n  })\n\n  // Print transformation\n\n  if (attrTransformConfig.devMode) {\n    const devMode = attrTransformConfig.devMode\n    const code = getSourceFromNodePath(program)\n    if (devMode.onlyTranformation) {\n      log.logLines = [] // clear log\n    }\n    if (devMode.onlyFiles) {\n      let onlyFiles = devMode.onlyFiles\n      const name = fileName.split(\"/\").pop()!\n      const nameNoExtension = name.replace(/\\.[^/.]+$/, \"\")\n      if (!Array.isArray(onlyFiles)) {\n        onlyFiles = [onlyFiles]\n      }\n      const fileNameMatch = onlyFiles.some((file) => {\n        if (typeof file === \"string\") {\n          return file === fileName || file === name || file === nameNoExtension\n        } else {\n          return file.test(fileName) || file.test(name) || file.test(nameNoExtension)\n        }\n      })\n      if (!fileNameMatch) {\n        return\n      }\n    }\n\n    log.msg(`\\n\\n`)\n    log.header(`Transformed Code`)\n    log.note(`jsx-transform.macro (DevMode Transformed)`)\n    log.note(`file: ${params.state.filename}`)\n\n    log.msg(code, \"white\")\n    log.msg(\"\\n\")\n    log.end()\n    log.msg(\"\\n\\n\")\n\n    let logMessage: string | undefined\n    if (devMode.colors === true) {\n      logMessage = log.getColorLog()\n    } else if (devMode.colors === false) {\n      logMessage = log.getLog()\n    }\n\n    if (devMode.logToConsole) {\n      if (logMessage === undefined) {\n        logMessage = log.getColorLog()\n      }\n      console.log(logMessage)\n    }\n    if (devMode.logWithThrow) {\n      if (logMessage === undefined) {\n        logMessage = log.getColorLog()\n      }\n      throw new MacroError(logMessage)\n    }\n    if (devMode.printToFile) {\n      if (logMessage === undefined) {\n        logMessage = log.getLog()\n      }\n      let deugFileName = \"attr-transform.macro.debug-log.txt\"\n      if (typeof devMode.printToFile === \"string\") {\n        deugFileName = devMode.printToFile\n      }\n      const path = require(\"path\")\n      const debugFilePath = path.join(process.cwd(), deugFileName)\n      if (!sessionStartet) {\n        sessionStartet = true\n        //fs.writeFileSync(debugFilePath, \"\") // clear file\n      }\n      const splitter = \"#####################__##__attr-tranform__##__#########################\"\n\n      const lastContent = x.loadSync(debugFilePath)\n      let fileLine = `########## ${fileName}`\n      const newContent = `\\n${fileLine}\\n${logMessage}`\n      if (lastContent.length > 0) {\n        const parts = lastContent.split(splitter)\n        // contains content\n        const findPart = parts.findIndex((part) => {\n          return part.includes(fileLine)\n        })\n        if (findPart >= 0) {\n          // already contains file line\n          parts.splice(findPart, 1, newContent)\n        } else {\n          parts.push(newContent)\n        }\n        const newFileContent = parts.join(splitter)\n        x.saveSync(debugFilePath, newFileContent)\n      } else {\n        const newFileContent = `${splitter}\\n${newContent}`\n        x.saveSync(debugFilePath, newFileContent)\n      }\n    }\n  }\n\n  log.msg(`\\n`)\n  log.header(\"attr-attribute.macro : DONE\", \"blackBright\")\n  log.msg(`\\n\\n`)\n}\n\nexport default createMacro(macro, { configName: \"attr-transform\" })\n","import { MacroError } from \"babel-plugin-macros\"\nimport { join } from \"path\"\n\nimport type { AttrTransformConfig, AttrTransformMacroParams } from \"./attr-transform.config-types\"\n\nimport { Logger } from \"./logger\"\n\nexport function loadConfig(params: AttrTransformMacroParams, log: Logger): AttrTransformConfig {\n  let config: AttrTransformConfig = {}\n  const { config: babelMacroConfig } = params\n  log.header(`Config`)\n  log.note(`(from babel-macro-pluing under 'attr-transform' section)`)\n  log.object(babelMacroConfig)\n  log.end()\n\n  // Get the config in babel-macro config: https://github.com/kentcdodds/babel-plugin-macros/blob/main/other/docs/author.md\n  // Or from file\n\n  let configFile: string | undefined = undefined\n  if (babelMacroConfig?.config === undefined) {\n    configFile = \"attr-transform.config.cjs\"\n  } else if (typeof babelMacroConfig?.config === \"string\") {\n    configFile = babelMacroConfig.config\n  } else {\n    config = babelMacroConfig\n  }\n\n  if (configFile) {\n    const baseDirectory = process.cwd()\n    //throw new MacroError(\"baseDirectory: \" + baseDirectory)\n    //log(\"baseDirectory: \" + baseDirectory, \"configFile: \" + configFile)\n    const configFilePath = join(baseDirectory, configFile)\n    log.note(`Loading config from file: `, \"cyan\")\n    log.note(`path: ${configFilePath}`, \"blackBright\")\n    const configFromFile = require(configFilePath) as AttrTransformConfig\n    config = configFromFile\n  } else if (babelMacroConfig?.elms) {\n    config = babelMacroConfig\n  } else {\n    throw new MacroError(\n      `\n        You must provide a config file (or a 'attr-transform.elms' object in the babel-plugin-macro config - https://github.com/kentcdodds/babel-plugin-macros/blob/main/other/docs/author.md):\n        [attr-transform.config.js]\n        /** @type {import('../src/twin-atttributes.types.ts').TwinAttributeConfig} */\n        module.exports = {\n          elms: [\n            {\n              attrs: {\n                padding: {\n                  matchName: /p([0-9])/,\n                  replaceValue: ({match}) => \\`p-\\${match[1]}\\`,\n                },\n                color: {\n                  matchName: /([red|blue|green])/,\n                  replaceValue: ({match}) => \\`text-\\${match[1]}-600\\`,\n                },\n                line: {\n                  matchName: /line-([0-9])/,\n                  replaceValue: \"flex items-center justify-start\",\n                } \n              },\n            },\n          ],\n        }\n        `\n    )\n  }\n\n  if (config.devMode && config.devMode.maxDepth) {\n    log.maxDepth = config.devMode.maxDepth\n  }\n  return config\n}\n","import type { NodePath, types as T } from \"@babel/core\";\n\nimport { MacroError, createMacro } from \"babel-plugin-macros\";\nimport { join } from \"path\";\nimport cli from \"cli-color\";\n\nimport type {\n  AttrMatch,\n  AttrTransformConfig,\n  AttrTransformMacroParams,\n  FullLegalAttributeValues,\n  PostActionMatch,\n  PostMatchAction,\n} from \"./attr-transform.config-types\"\nimport { FindMatchingAttributesConfig, MatchElm, getJsxAttributes } from \"./nodeMatch\"\nimport { replaceNameAndOrValue } from \"./attr-actions\"\n\nimport { Logger } from \"./logger\"\n\nexport function traverseJSXElement(\n  path: NodePath<T.JSXElement>,\n  attrTransformConfig: AttrTransformConfig,\n  params: AttrTransformMacroParams,\n  attributesToRemove: NodePath<T.JSXAttribute>[],\n  t: typeof T,\n  log: Logger\n) {\n  if (!attrTransformConfig.elms) return;\n\n  const jsxAttributePaths = getJsxAttributes(path);\n\n  // Test matching tag (elm)\n  const { elm, tagName, tagMatch, matchingElmConfig } = MatchElm(path, attrTransformConfig.elms);\n  const line = elm.node.loc?.start.line ?? 0;\n  const end = elm.node.loc?.start.line ?? 0;\n  const startColumn = elm.node.loc?.start.column;\n  const endColumn = elm.node.loc?.start.column;\n  const lines = end - line + 1;\n  log.header(`traverse - JSXElement: ${tagName} - Line: ${line}:${startColumn} to ${end}:${endColumn}`, \"bgBlue\");\n  if (lines < 4) {\n    for (let i = 0; i < lines; i++) {\n      log.contentLine(line + i);\n    }\n  } else {\n    log.contentLine(line + 1);\n    log.contentLine(line + 2);\n    log.msg(`...`);\n    log.contentLine(end - 1);\n    log.contentLine(end);\n  }\n\n  if (!matchingElmConfig) {\n    log.note(`No Elm Confiog not macthed!`, \"redBright\");\n    log.end();\n    return false;\n  }\n\n  // Match attributes\n  const foundAttributes = jsxAttributePaths\n    .map((attrPath) => FindMatchingAttributesConfig(params, matchingElmConfig, elm, tagMatch, attrPath))\n    // remove undefined\n    .filter((x) => !!x) as AttrMatch[];\n  // list elm actions\n  const postMatchActions: PostMatchAction[] = matchingElmConfig.actions ?? [];\n\n  if (foundAttributes.length === 0 && postMatchActions.length === 0) {\n    log.note(`No attribute matched and no actions defined\\n`, \"redBright\");\n    log.end();\n\n    return;\n  }\n  log.note(\n    `Found ${foundAttributes.length} attributes: ${foundAttributes.map((x) => x.nodePath.node.name.name).join(\", \")}`\n  );\n\n  const collectedAttributes: AttrMatch[] = [];\n  const steps: { [key: string]: (foundProp: AttrMatch) => void } = {\n    collect: (foundProp) => {\n      if (foundProp.collected) {\n        collectedAttributes.push(foundProp);\n      }\n    },\n    setMeta: (foundProp) => {\n      foundProp.allMatchingAttributes = foundAttributes;\n      foundProp.collectedAttributes = collectedAttributes;\n    },\n    setValues: (foundProp) => {\n      if (foundProp?.valueFunction) {\n        foundProp.value = foundProp.valueFunction(foundProp);\n      }\n    },\n    callValidators: (foundProp) => {\n      if (foundProp?.validateFunction) {\n        const errorMessage = foundProp.validateFunction(foundProp);\n        if (errorMessage) {\n          let errorText =\n            cli.redBright(\"âŒ\") +\n            cli.redBright(\" Validation error\") +\n            cli.blackBright(\" (jsx-transform.macro)\") +\n            cli.blackBright(\"\\n\\n in \") +\n            cli.cyan(params.state.filename) +\n            cli.blackBright(\"\\n at \") +\n            cli.cyan(\"line \" + path.node.loc?.start.line) +\n            cli.blackBright(\":\\n\\n  \") +\n            cli.red(\"  \" + errorMessage);\n\n          throw new MacroError(`\\n\\n${errorText}\\n\\n`);\n        }\n      }\n    },\n  };\n\n  // Run steps\n  Object.values(steps).forEach((step) => {\n    foundAttributes.forEach(step);\n  });\n\n  log.note(`Run attribute actions (count: ${foundAttributes.length})`, \"blackBright\");\n  // Attributes Actions\n  for (const foundProp of foundAttributes) {\n    log.subheader(`Attr: ${foundProp.nodePath.node.name.name} - Source:`, \"cyan\");\n    log.nodePath(foundProp.nodePath);\n    log.subheader(`Value from attr config: ${foundProp.value}`, \"blackBright\");\n    if (foundProp.attrConfig.replaceName || foundProp.attrConfig.replaceValue) {\n      replaceNameAndOrValue(foundProp, t, log);\n    }\n    log.note(`End attribute parsing`);\n  }\n\n  log.subheader(`Run elm actions conditions`, \"blackBright\");\n\n  const matchedActions = postMatchActions\n    .map((action) => {\n      const matchAction: PostActionMatch = {\n        name: action.name ?? \"\",\n        value: \"\",\n        postMatchAction: action,\n        allMatchingAttributes: foundAttributes,\n        collectedAttributes: collectedAttributes,\n        elmNodePath: elm,\n        tagMatch: tagMatch,\n        macroParams: params,\n      };\n      // conditions\n      if (action.condition) {\n        const match = action.condition(matchAction);\n        if (!match) return;\n\n        if (action.value && typeof action.value === \"function\") {\n          matchAction.value = action.value(matchAction);\n        } else if (action.value) {\n          matchAction.value = action.value;\n        }\n\n        return matchAction;\n      }\n      return matchAction;\n    })\n    .filter((x) => !!x) as PostActionMatch[];\n\n  log.note(`Found ${postMatchActions.length} Elm actions: ${postMatchActions.map((x) => x.name)}`);\n\n  log.note(`Macthed Elm action  - (condition met) (count: ${matchedActions.length})`, \"blackBright\");\n\n  // Post match actions\n  for (const action of matchedActions) {\n    log.subheader(`Action: ${action.name ?? \" (no name)\"}`, \"cyan\");\n\n    let value = action.value;\n\n    if (action.postMatchAction.createAttribute) {\n      log.note(`Elm action: createAttribute`, \"blackBright\");\n\n      const attr = action.postMatchAction.createAttribute;\n      if (typeof attr === \"string\") {\n        const newAttrName = attr;\n        const existingAttribute = jsxAttributePaths.find((attr) => attr.node.name.name === newAttrName);\n        // New value:\n        let newAttr: T.JSXAttribute | undefined;\n        const id = t.jsxIdentifier(newAttrName);\n        if (!value) {\n          newAttr = t.jsxAttribute(id);\n        } else if (typeof value === \"string\") {\n          newAttr = t.jsxAttribute(id, t.stringLiteral(value));\n        } else if (typeof value === \"number\") {\n          newAttr = t.jsxAttribute(id, t.jsxExpressionContainer(t.numericLiteral(value)));\n        } else if (typeof value === \"boolean\") {\n          newAttr = t.jsxAttribute(id, t.jsxExpressionContainer(t.booleanLiteral(value)));\n        } else if (t.isNode(value)) {\n          newAttr = t.jsxAttribute(id, value);\n        }\n        if (newAttr) {\n          if (!existingAttribute) {\n            // Add new attribute\n            elm.node.attributes.push(newAttr);\n            log.note(`attribute added`);\n            log.object(newAttr);\n          } else if (action.value) {\n            existingAttribute.replaceWith(newAttr);\n            log.note(`existing attribute replaced`);\n            log.nodePath(existingAttribute);\n          }\n        }\n      }\n    }\n  }\n\n  // remove props\n  for (const foundProp of foundAttributes) {\n    if (attributesToRemove.includes(foundProp.nodePath)) continue;\n    if (foundProp.attrConfig.remove) {\n      attributesToRemove.push(foundProp.nodePath);\n    }\n  }\n}\n","import type { NodePath, types as T } from \"@babel/core\";\n\nimport type {\n  AttrMatch,\n  AttrTransformMacroParams,\n  AttrValueFunc,\n  ElmConfig,\n  MatchValueFunc,\n  ValidateValueFunc,\n} from \"./attr-transform.config-types\"\n\nexport function getJsxAttributes(nodePath: NodePath<T.JSXElement>) {\n  let attributes = nodePath.get(\"openingElement.attributes\") as NodePath<T.JSXAttribute>[];\n  if (!Array.isArray(attributes)) {\n    attributes = [attributes];\n  }\n  return attributes.filter((x) => x?.isJSXAttribute());\n}\n\nexport function MatchElm(path: NodePath<T.JSXElement>, elms: ElmConfig[]) {\n  const elm = path.get(\"openingElement\");\n  const tagName = (elm.node.name as T.JSXIdentifier).name?.toString() ?? \"\";\n  if (!tagName) return { elm, tagName, tagMatch: null, matchingElmConfig: undefined };\n  let tagMatch: RegExpMatchArray | null = null;\n  const matchingElmConfig = elms.find((elmConfig) => {\n    if (elmConfig.match === undefined) return true;\n    if (typeof elmConfig.match === \"string\") {\n      tagMatch = tagName === elmConfig.match ? [tagName] : null;\n    }\n    if (elmConfig.match instanceof RegExp) {\n      tagMatch = tagName.match(elmConfig.match);\n    }\n    if (!tagMatch) return false;\n    if (elmConfig.dontMatch) {\n      const dontMatch = tagName.match(elmConfig.dontMatch);\n      if (dontMatch) return false;\n    }\n    return true;\n  });\n  return { elm, tagName, tagMatch, matchingElmConfig };\n}\n\nexport function FindMatchingAttributesConfig(\n  macroParams: AttrTransformMacroParams,\n  elmConfig: ElmConfig,\n  elmNodePath: NodePath<T.JSXOpeningElement>,\n  tagRegExpMatch: RegExpMatchArray | null,\n  attrNodePath: NodePath<T.JSXAttribute>\n): AttrMatch | undefined {\n  if (!attrNodePath.node || !elmNodePath.node) return;\n  if (attrNodePath.removed) return;\n  const attrName = attrNodePath.node.name.name.toString();\n  const attrsConfig = Object.entries(elmConfig.attrs);\n  // iterate attrConfig (elm attributes)\n  for (const [name, attrConfig] of attrsConfig) {\n    let attrMatch: RegExpMatchArray | null = null;\n    let value = \"\";\n    let valueFunction: AttrValueFunc | undefined;\n    let validateFunction: ValidateValueFunc | undefined;\n    let matchFunction: MatchValueFunc | undefined;\n    let dontMatchFunction: MatchValueFunc | undefined;\n\n    // match\n    if (attrConfig.matchName) {\n      if (typeof attrConfig.matchName === \"string\") {\n        attrMatch = attrName === attrConfig.matchName ? [attrName] : null;\n        if (!attrMatch) continue; // no match\n      }\n      if (attrConfig.matchName instanceof RegExp) {\n        attrMatch = attrName.match(attrConfig.matchName);\n        if (!attrMatch) continue; // no match\n      }\n      if (typeof attrConfig.matchName === \"function\") {\n        matchFunction = attrConfig.matchName; // finish after collect all attributes\n      }\n    }\n    // dontMatch\n    if (attrConfig.dontMatchName) {\n      if (typeof attrConfig.dontMatchName === \"string\") {\n        const dontMatch = attrName === attrConfig.dontMatchName;\n        if (dontMatch) continue; // no match\n      }\n      if (attrConfig.dontMatchName instanceof RegExp) {\n        const dontMatch = attrName.match(attrConfig.dontMatchName);\n        if (dontMatch) continue; // no match\n      }\n      if (typeof attrConfig.dontMatchName === \"function\") {\n        dontMatchFunction = attrConfig.dontMatchName; // finish after collect all attributes\n      }\n    }\n    // validate\n    if (typeof attrConfig.validate === \"function\") {\n      validateFunction = attrConfig.validate; // finish after collect all attributes\n    }\n    // value\n    if (typeof attrConfig.value === \"string\") {\n      value = attrConfig.value;\n    } else if (typeof attrConfig.value === \"function\") {\n      valueFunction = attrConfig.value; // finish after collect all attributes\n    } else if (typeof attrConfig.replaceValue === \"function\") {\n      valueFunction = attrConfig.replaceValue; // finish after collect all attributes\n    } else {\n      // is string literal\n      if (attrNodePath.node.value?.type === \"StringLiteral\") {\n        value = attrNodePath.node.value?.value?.toString() ?? \"\";\n      }\n    }\n\n    let collected = attrConfig.collect ?? false;\n\n    const fount: AttrMatch = {\n      name,\n      value, // set from attrConfig function call later\n      matchFunction,\n      dontMatchFunction,\n      validateFunction,\n      valueFunction,\n      attrConfig,\n      match: attrMatch,\n      collected,\n      tagMatch: tagRegExpMatch,\n      allMatchingAttributes: [], // finish after collect all attributes: get after grouping\n      collectedAttributes: [], // finish after collect all attributes: get after grouping\n      nodePath: attrNodePath,\n      elmNodePath: elmNodePath,\n      macroParams,\n    };\n    return fount;\n  }\n}\n"],"names":["e","Object","assign","bind","n","arguments","length","r","t","prototype","hasOwnProperty","call","apply","this","getSourceFromNodePath","path","generator","require","node","code","Logger","logLines","content","indent","maxDepth","showUndefined","showNull","lineWith","enabled","_proto","stringify","obj","leadingComma","repeat","i","WeakSet","a","o","removeKeys","includes","f","u","l","Date","toISOString","toString","RegExp","has","add","Array","isArray","s","d","entries","p","g","object","color","json","msg","nodePath","message","push","contentLine","line","split","note","header","subheader","end","prefix","len","getColorLog","map","x","clc","join","getLog","replaceNameAndOrValue","foundProp","log","newName","id","newValueNode","newValue","attrConfig","replaceName","jsxIdentifier","name","replaceValue","stringLiteral","jsxExpressionContainer","numericLiteral","booleanLiteral","isNode","value","newAttr","jsxAttribute","replaceWith","createMacro","params","babel","types","program","state","file","fileName","filename","attributesToRemove","attrTransformConfig","config","babelMacroConfig","configFile","undefined","baseDirectory","process","cwd","configFilePath","elms","MacroError","devMode","loadConfig","traverse","JSXElement","_elm$node$loc$start$l","_elm$node$loc","_elm$node$loc$start$l2","_elm$node$loc2","_elm$node$loc3","_elm$node$loc4","_matchingElmConfig$ac","attributes","jsxAttributePaths","get","filter","isJSXAttribute","_MatchElm","_elm$node$name$name$t","_elm$node$name$name","elm","tagName","tagMatch","matchingElmConfig","find","elmConfig","match","dontMatch","MatchElm","loc","start","startColumn","column","endColumn","lines","foundAttributes","attrPath","macroParams","elmNodePath","tagRegExpMatch","attrNodePath","removed","attrName","_i","_attrsConfig","attrs","_attrConfig$collect","_attrsConfig$_i","attrMatch","valueFunction","validateFunction","matchFunction","dontMatchFunction","matchName","dontMatchName","validate","_attrNodePath$node$va","_attrNodePath$node$va2","_attrNodePath$node$va3","_attrNodePath$node$va4","type","collected","collect","allMatchingAttributes","collectedAttributes","FindMatchingAttributesConfig","postMatchActions","actions","steps","setMeta","setValues","callValidators","errorMessage","_path$node$loc","errorText","cli","redBright","blackBright","cyan","red","values","forEach","step","_iterator","_step","_createForOfIteratorHelperLoose","done","matchedActions","action","_action$name","matchAction","postMatchAction","condition","_step2","_loop","_action$name2","createAttribute","attr","newAttrName","existingAttribute","_iterator2","_iterator3","_step3","remove","traverseJSXElement","scope","crawl","logMessage","onlyTranformation","onlyFiles","pop","nameNoExtension","replace","some","test","colors","logToConsole","console","logWithThrow","printToFile","deugFileName","debugFilePath","splitter","lastContent","loadSync","fileLine","newContent","parts","findPart","findIndex","part","splice","newFileContent","saveSync","configName"],"mappings":"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"}